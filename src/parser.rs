use std::fmt::Debug;

use chumsky::prelude::*;

use crate::{
    ast::{Expr, ExprRef, Literal},
    lexer::{Span, Spanned, Token},
};

// The type of the input that our parser operates on. The input is the `&[(Token, Span)]` token buffer generated by the
// lexer, wrapped in a `SpannedInput` which 'splits' it apart into its constituent parts, tokens and spans, for chumsky
// to understand.
pub type ParserInput<'tokens> = chumsky::input::SpannedInput<Token, Span, &'tokens [(Token, Span)]>;

pub type ParseError<'a> = extra::Err<Rich<'a, Token, Span>>;

pub fn expr_parser<'a>() -> impl Parser<'a, ParserInput<'a>, ExprRef, ParseError<'a>> {
    recursive(|expr| {
        let primary = primary_parser();

        let group = spanned(expr)
            .clone()
            .delimited_by(just(Token::LeftParen), just(Token::RightParen))
            .map(Expr::Group);

        primary.or(group)
    })
    .map_with_span(|expr, span| ExprRef::new(span.into(), expr))
}

pub fn primary_parser<'a>() -> impl Parser<'a, ParserInput<'a>, Expr, ParseError<'a>> + Clone {
    select! {
        Token::True => Expr::Literal(Literal::True),
        Token::False => Expr::Literal(Literal::False),
        Token::String(string) => Expr::Literal(Literal::String(string)),
    }
    .labelled("primary")
}

fn spanned<'a, P, T: Debug + Clone>(
    parser: P,
) -> impl Parser<'a, ParserInput<'a>, Spanned<T>, ParseError<'a>> + Clone
where
    P: Parser<'a, ParserInput<'a>, T, ParseError<'a>> + Clone,
{
    parser.map_with_span(|expr, span: Span| Spanned::<T>::new(span.into(), expr))
}
