use chumsky::prelude::*;

use crate::{
    ast::{Expr, ExprRef, Literal},
    lexer::{Span, Token},
};

// The type of the input that our parser operates on. The input is the `&[(Token, Span)]` token buffer generated by the
// lexer, wrapped in a `SpannedInput` which 'splits' it apart into its constituent parts, tokens and spans, for chumsky
// to understand.
type ParserInput<'tokens> = chumsky::input::SpannedInput<Token, Span, &'tokens [(Token, Span)]>;

pub type ParseError<'a> = extra::Err<Rich<'a, Token, Span>>;

pub fn primary_parser<'a>() -> impl Parser<'a, ParserInput<'a>, ExprRef, ParseError<'a>> {
    select! {
        Token::True => Expr::literal(Literal::bool(true)),
        Token::False => Expr::literal(Literal::bool(false)),
        Token::String(string) => Expr::literal(Literal::string(string)),
    }
}
