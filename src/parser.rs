use chumsky::prelude::*;

use crate::ast::{Binary, Expr, ExprRef, FunctionId, Literal};
use crate::lexer::{Span, Spanned, Token, SYMBOLS};

/// The type of the input that our parser operates on. The input is the `&[(Token, Span)]` token buffer generated by the
/// lexer, wrapped in a `SpannedInput` which 'splits' it apart into its constituent parts, tokens and spans, for chumsky
/// to understand.
pub type ParserInput<'tokens> = chumsky::input::SpannedInput<Token, Span, &'tokens [(Token, Span)]>;

pub type ParseError<'a> = extra::Err<Rich<'a, Token, Span>>;

pub fn expr_parser<'a>() -> impl Parser<'a, ParserInput<'a>, ExprRef, ParseError<'a>> {
    spanned!(recursive(|expr| {
        let group = spanned!(expr)
            .clone()
            .delimited_by(just(Token::LeftParen), just(Token::RightParen))
            .map(Expr::Group);

        let literal = literal_parser().or(group);

        // `^`, `>>`, `<<`, `|`, `&`
        let bitwise = binary! {
            spanned!(literal)
            .then(op("^").or(op(">>")).or(op("<<")).or(op("|")).or(op("&")))
            .then(spanned!(literal))
        };

        // `>`, `>=`, `<=`, `<`
        let int_cmp = binary! {
            spanned!(bitwise)
            .then(op(">").or(op(">=")).or(op("<=")).or(op("<")))
            .then(spanned!(bitwise))
        };

        // `==`, `!=`
        let eq_cmp = binary! {
            spanned!(int_cmp)
            .then(op("==").or(op("!=")))
            .then(spanned!(int_cmp))
        };

        // `&&`, `||`
        let bool_cmp = binary! {
            spanned!(eq_cmp)
            .then(op("&&").or(op("||")))
            .then(spanned!(eq_cmp))
        };

        // `$`, `%`, `->`, `=>`, `=>>`, `@`
        let infix_fn = binary! {
            spanned!(bool_cmp)
            .then(op("$").or(op("%")).or(op("->")).or(op("=>")).or(op("=>>")).or(op("@")))
            .then(spanned!(bool_cmp))
        };

        // `^^`
        let pow = binary! {
            spanned!(infix_fn)
            .then(op("^^"))
            .then(spanned!(infix_fn))
        };

        // `*`, `/`
        let factor = binary! {
            spanned!(pow)
            .then(op("*").or(op("/")))
            .then(spanned!(pow))
        };

        // `+`, `-`
        let term = binary! {
            spanned!(factor)
            .then(op("+").or(op("-")))
            .then(spanned!(pow))
        };

        pow
    }))
}

pub fn literal_parser<'a>() -> impl Parser<'a, ParserInput<'a>, Expr, ParseError<'a>> + Clone {
    select! {
        Token::True => Expr::Literal(Literal::True),
        Token::False => Expr::Literal(Literal::False),
        Token::String(string) => Expr::Literal(Literal::String(string)),
    }
    .labelled("primary")
}

fn op<'a>(name: &str) -> impl Parser<'a, ParserInput<'a>, String, ParseError<'a>> + Clone {
    let name: String = name.into();
    symbol().filter(move |x| x.clone() == name.clone())
}

fn symbol<'a>() -> impl Parser<'a, ParserInput<'a>, String, ParseError<'a>> + Clone {
    any()
        .try_map(|tok, span| match tok {
            Token::Symbol(symbol) => Ok(symbol),
            _ => Err(Rich::custom(span, "Expected infix symbol")),
        })
        .repeated()
        .collect()
        .map(|x: Vec<String>| x.join(""))
}

macro_rules! spanned {
    ($e:expr) => {
        $e.clone()
            .map_with_span(|expr, span: Span| Spanned::new(span.into(), expr))
    };
}

macro_rules! binary {
    ($e:expr) => {
        $e.map(|((lhs, fn_id), rhs)| {
            Expr::Binary(Binary {
                lhs,
                fn_id: FunctionId::new(&fn_id),
                rhs,
            })
        })
    };
}

use binary;
use spanned;
